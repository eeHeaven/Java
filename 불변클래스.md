### 불변클래스(Immutable Class)란?
 - 변경이 불가능한 클래스이며, 가변적이지 않는 클래스      
 -  레퍼런스 타입의 객체이기 때문에 heap영역에 생성       
 -  heap영역에서 변경불가능 한 것이지 재할당을 못하는 것은 아님          
 -  즉, 참조하고 있는 heap영역의 객체가 바뀌는 것이지 heap영역에 있는 값이 바뀌는 것이 아님            

#### 대표적인 불변클래스 종류들 
********************
 String, Boolean, Integer, Float, Long
********************
String a = "aa"; 에서 a = "bb" 로 재할당이 가능           
 a가 처음에 참조하고 있는 "aa"값이 "bb"로 변경되는 것이 아니라 아예 "bb"라는 새로운 객체를 만들고 그 객체를 a가 참조하게 하는 것                 
 이렇게 했을 경우 "aa"값을 지니고있는 객체는 이제 그 누구도 참조하고 있지 않는 객체가 되며 gc대상이 됨                    
 
 
### Immutable의 장점
 - **생성자, 접근메서드에 대한 방어 복사가 필요 없음**                     

여기서 방어 복사(깊은 복사)란 참조변수끼리 복사하는 얕은 복사가 이루어지지 않도록 내부 내용 값까지 전부 복사하는 깊은 복사를 말함          

 - **실패 원자적인(Failure Atomic) 메소드를 만들 수 있음**                

가변 객체를 통해 어떠한 작업을 하는 도중 예외가 발생하면 해당 객체가 불안정한 상태에 빠질 수 있다.           
그리고 불한정한 상태를 갖는 객체는 또 다른 에러를 유발할 수 있다.           
하지만 불변 객체라면 어떠한 예외가 발생하여도 메소드 호출 전의 상태를 유지할 수 있을 것이다.            
그리고 예외가 발생하여도 오류가 발생하지 않은 것 처럼 다음 로직을 처리할 수 있다.        

 - **멀티스레드 환경에서 동기화처리 없이 객체 공유 가능**                

 멀티 쓰레드 환경에서 동기화 문제가 발생하는 이유는 공유 자원에 동시에 쓰기(Write) 때문이다.          
 하지만 만약 공유 자원이 불변의 자원이라면 어떻게 될까? 더 이상 동기화를 고려하지 않아도 될 것이다.         
 왜냐하면 항상 동일한 값을 반환할 것이기 때문이다. 이는 안정성을 보장할 뿐만 아니라 동기화를 하지 않음으로써 성능상의 이점도 가져다준다.             
 
  - **Cache나 Map의 또는 Set 등의 요소로 활용하기에 더욱 적합함**           

만약 캐시나 Map 또는 Set 등으로 사용되는 객체가 변경되었다면 이를 갱신하는 등의 작업을 추가로 해주어야 할 것이다.       
하지만 객체가 불변이라면 한 번 데이터가 저장된 이후에 다른 부가 작업들을 고려하지 않아도 될 것이고, 이는 캐시나 다른 자료 구조를 사용하는데 용이하게 작용할 것이다.       

- **가비지 컬렉션의 성능을 높일 수 있음**           

불변성(Immutability)을 활용하는 것은 많은 이점을 가져다주는데, 그 중에서 많은 사람들이 놓치는 것이 바로 GC의 성능을 높여준다는 것이다.           
불변의 객체는 한번 생성된 이후에 수정이 불가능한 객체로, Java에서는 final 키워드를 사용하여 불변의 객체를 생성할 수 있다.          
이렇게 객체를 생성하기 위해서는 객체를 가지는 컨테이너도 존재한다는 것인데, 당연히 불변의 객체가 먼저 생성되어야 컨테이너가 이 객체를 참조할 수 있을 것이다.         
즉, 컨테이너는 컨테이너가 참조하는 가장 젊은 객체들보다 더 젊다는 것(늦게 생성되었다는 것)이다.       
이러한 점은 GC가 수행될 때, 가비지 컬렉터가 컨테이너 하위의 불변 객체들은 Skip할 수 있도록 도와준다.        
왜냐하면 해당 컨테이너가 살아있다는 것은 하위의 불변 객체들 역시 처음에 할당된 그 상태로 참조되고 있다는 것을 의미하기 때문이다.              
결국 불변의 객체를 활용하면 가비지 컬렉터가 스캔해야 되는 객체의 수가 줄어서 스캔해야 하는 메모리 영역과 빈도수 역시 줄어들 것이고, GC가 수행되어도 지연 시간을 줄일 수 있을 것이다.                

### Immutable의 단점

 - **객체가 가지는 값마다 새로운 객체가 필요하기 때문에 메모리 누수와 새로운 객체를 계속 생성해야하기 때문에 성능저하를 발생시킬 수 있음**          


### Immutable String 예시
*******************
```java
String a = "Star";
a = a.concat("Craft");
System.out.println(a);
```
![캡처](https://user-images.githubusercontent.com/84822464/125294902-a6840400-e35f-11eb-9808-c34814e40f84.PNG)         
이때 a는 메모리주소 1000을 저장하던 참조변수에서 메모리주소 2000을 저장하고 있는 참조 변수가 된다.          


### Immutable 객체와 Class 만들기 
********************
#### final 선언으로 Immutable 객체 만들기 

Java에서는 불변성을 확보할 수 있도록 final 키워드를 제공하고 있다.        
Java에서 변수들은 기본적으로 가변적인데, 변수에 final 키워드를 붙이면 참조값을 변경 못하도록 하여 불변성을 확보할 수 있다.       

```java
final String name = "Old";
name = "New"; // 컴파일 에러
```
Java에서는 final이 붙은 변수의 값을 변경하려고 하면 컴파일 에러가 발생한다. 하지만 final 키워드가 내부의 객체 상태를 변경하지 못하도록 하는 것은 아니다.            
예를 들어 아래와 같이 final로 선언된 List에는 새로운 객체가 더해져도(상태가 변해도) 문제가 없다.          

```java
final List<String> list = new ArrayList<>(); 
list.add("a");
```
 
 #### 불변클래스 만들기
 
1. 클래스를 final로 선언하라         
2. 모든 클래스 변수를 private와 final로 선언하라        
3. 객체를 생성하기 위한 생성자 또는 정적 팩토리 메소드를 추가하라         
4. 참조에 의해 변경가능성이 있는 경우 방어적 복사를 이용하여 전달하라            

```java
public final class ImmutableClass { 
    private final int age;
    private final String name; 
    private final List<String> list; 

    private ImmutableClass(int age, String name) {
      this.age = age;
      this.name = name;
      this.list = new ArrayList<>();
    } 
    public static ImmutableClass of(int age, String name) {
      return new ImmutableClass(age, name); }
    public int getAge() { 
      return age; } 
    public String getName() { 
      return name; } 
    public List<String> getList() {
      return Collections.unmodifiableList(list);  //방어적 복사} 
}
```
위의 코드에서 특히 주목해야 하는 부분은 내부 생성자를 만드는 대신 객체의 생성을 위해 정적 팩토리 메소드를 제공하고 있다는 점과       
참조를 전달하여 클라이언트에 의해 수정가능성이 있는 list를 방어적 복사하여 제공하고 있다는 것이다.      
Java에서는 생성자를 선언하지 않으면 기본 생성자가 자동으로 생성되는데, 그러면 다른 클래스에서 해당 객체를 자유롭게 호출할 수 있다.           
그렇기 때문에 내부 생성자를 만드는 대신 정적 팩토리 메소드를 통해 객체를 생성하도록 강요하는 것이 좋다.          
또한 **배열이나 다른 객체 또는 컬렉션은 참조가 전달되어 수정가능성이 있다. 그렇기 때문에 참조를 통해 변경이 가능한 경우에는 방어적 복사를 통해 값을 반환해야 한다.**                 






